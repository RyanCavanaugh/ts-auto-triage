#!/usr/bin/env node

import { readFile, writeFile } from 'fs/promises';
import * as jsonc from 'jsonc-parser';
import { parseIssueRef, createConsoleLogger, ensureDirectoryExists, formatIssueRef, createAuthenticatedOctokit, formatActionsAsMarkdown } from '../lib/utils.js';
import { createAIWrapper } from '../lib/ai-wrapper.js';
import { ConfigSchema, GitHubIssueSchema, type IssueRef, type GitHubIssue, type Config } from '../lib/schemas.js';
import { executeTriggers, type RepositoryMetadata } from '../lib/curation-triggers.js';

async function main() {
  const logger = createConsoleLogger();
  
  try {
    // Load configuration first to get defaultRepo
    const configContent = await readFile('config.jsonc', 'utf-8');
    const config = ConfigSchema.parse(jsonc.parse(configContent));

    // Parse command line arguments
    const args = process.argv.slice(2);
    if (args.length !== 1) {
      console.error('Usage: curate-issue <issue-ref>');
      console.error('Example: curate-issue Microsoft/TypeScript#9998');
      console.error('Example: curate-issue #9998 (uses defaultRepo from config)');
      process.exit(1);
    }

    const issueRefInput = args[0]!;
    const issueRef = parseIssueRef(issueRefInput, config.defaultRepo);
    
    logger.info(`Curating issue: ${issueRef.owner}/${issueRef.repo}#${issueRef.number}`);

    // Create AI wrapper
    const ai = createAIWrapper(config.azure.openai, logger, config.ai.cacheEnabled);

    // Load the issue data
    const issueFilePath = `.data/${issueRef.owner.toLowerCase()}/${issueRef.repo.toLowerCase()}/${issueRef.number}.json`;
    let issue;
    try {
      const issueContent = await readFile(issueFilePath, 'utf-8');
      issue = GitHubIssueSchema.parse(JSON.parse(issueContent));
    } catch {
      logger.error(`Issue data not found at ${issueFilePath}. Run fetch-issue first.`);
      process.exit(1);
    }

    // Get repository metadata for valid labels and milestones
    const { labels, milestones } = await getRepositoryMetadata(issueRef);
    const metadata: RepositoryMetadata = { labels, milestones };

    // Execute triggers to get recommendations
    const recommendations = await executeTriggers(issue, issueRef, metadata, ai, config, logger);

    if (recommendations.length === 0) {
      logger.info('No curation actions recommended');
      return;
    }

    // Write action file
    const actionFile = {
      issue_ref: issueRef,
      actions: recommendations,
    };

    const actionFilePath = `.working/actions/${issueRef.owner.toLowerCase()}.${issueRef.repo.toLowerCase()}.${issueRef.number}.jsonc`;
    ensureDirectoryExists(actionFilePath);
    
    const actionFileContent = `/* Proposed curation actions for ${formatIssueRef(issueRef)}
   Generated by trigger-based curation system */
${JSON.stringify(actionFile, null, 2)}
/*
${formatActionsAsMarkdown(recommendations)}
*/`;

    await writeFile(actionFilePath, actionFileContent);
    logger.info(`Action file written to ${actionFilePath}`);
    logger.info(`Recommended ${recommendations.length} curation actions`);

  } catch (error) {
    logger.error(`Failed to curate issue: ${error}`);
    process.exit(1);
  }
}

export async function getRepositoryMetadata(issueRef: IssueRef): Promise<{ labels: string[]; milestones: string[] }> {
  try {
    // Create authenticated Octokit client
    const octokit = await createAuthenticatedOctokit();

    // Fetch all labels with pagination
    const allLabels = [];
    let labelsPage = 1;
    let hasMoreLabels = true;

    while (hasMoreLabels) {
      const labelsResponse = await octokit.issues.listLabelsForRepo({
        owner: issueRef.owner,
        repo: issueRef.repo,
        per_page: 100,
        page: labelsPage,
      });

      allLabels.push(...labelsResponse.data);
      
      // Check if there are more pages
      hasMoreLabels = labelsResponse.data.length === 100;
      labelsPage++;
    }

    // Fetch all milestones with pagination
    const allMilestones = [];
    let milestonesPage = 1;
    let hasMoreMilestones = true;

    while (hasMoreMilestones) {
      const milestonesResponse = await octokit.issues.listMilestones({
        owner: issueRef.owner,
        repo: issueRef.repo,
        state: 'all',
        per_page: 100,
        page: milestonesPage,
      });

      allMilestones.push(...milestonesResponse.data);
      
      // Check if there are more pages
      hasMoreMilestones = milestonesResponse.data.length === 100;
      milestonesPage++;
    }

    return {
      labels: allLabels.map(l => l.name),
      milestones: allMilestones.map(m => m.title),
    };
  } catch (error) {
    // Fallback to empty arrays if API calls fail
    return { labels: [], milestones: [] };
  }
}

main().catch(console.error);